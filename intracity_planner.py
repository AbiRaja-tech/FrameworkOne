#!/usr/bin/env python3
"""
Intracity day planner (CP-SAT) — Updated for fixed costs and POI-based stamina
================================================================================
This version implements the user's exact requirements:
- Fixed transport costs per trip (not per minute)
- POI-based stamina costs (liked/disliked categories)
- Distance-based cab pricing
- Proper transport mode handling (walk, bus, tram, train, cab)
"""

from __future__ import annotations
from typing import Dict, Any, Tuple, List, Optional
from ortools.sat.python import cp_model
import argparse, json, os, time, logging

# --------------------------------
# Logging
# --------------------------------
def setup_logging(log_level: str = "INFO", log_file: str = "intracity_planner.log"):
    """Setup logging to both console and file"""
    log = logging.getLogger("intracity")
    log.setLevel(getattr(logging, log_level.upper()))
    
    # Clear existing handlers
    log.handlers.clear()
    
    # Console handler
    console_handler = logging.StreamHandler()
    console_handler.setLevel(logging.INFO)
    console_formatter = logging.Formatter("[%(levelname)s] %(message)s")
    console_handler.setFormatter(console_formatter)
    log.addHandler(console_handler)
    
    # File handler
    file_handler = logging.FileHandler(log_file, mode='w', encoding='utf-8')
    file_handler.setLevel(logging.DEBUG)
    file_formatter = logging.Formatter('%(asctime)s [%(levelname)s] %(message)s')
    file_handler.setFormatter(file_formatter)
    log.addHandler(file_handler)
    
    return log

# Initialize logging
log = setup_logging()

# --------------------------------
# Small helpers
# --------------------------------
def _namekey(s: str) -> str:
    """Lowercased, trimmed key for dict lookups."""
    return (s or "").strip().casefold()

def _num(v) -> Optional[float]:
    """Parse possibly-string cell like 'X', '', '  ', '28' → float or None."""
    if v is None:
        return None
    if isinstance(v, (int, float)):
        return float(v)
    s = str(v).strip()
    if s == "" or s.lower() in {"x", "na", "n/a", "-"}:
        return None
    try:
        return float(s)
    except Exception:
        return None

def _pick(rec: Dict[str, Any], *candidates: str) -> Optional[float]:
    """Return first numeric value among candidate keys (float) or None."""
    for k in candidates:
        if k in rec:
            val = _num(rec[k])
            if val is not None:
                return val
    return None

def _pick_edge_km(rec: Dict[str, Any]) -> Optional[float]:
    """Choose a sensible edge distance (km) from any available distance-like keys."""
    # Priority order — cab distance tends to correspond to road distance
    for ks in [
        ("edge_km",),
        ("cab_km","Cab_dist","Cab_distance"),
        ("walk_km","Walk_dist","Walk_distance"),
        ("bus_km","Bus_dist","Bus_distance"),
        ("tram_km","Tram_dist","Tram_distance","tram/tube_dist","tram/tube_distance")
    ]:
        v = _pick(rec, *ks)
        if v is not None:
            return v
    return None

def _get_time_fields(rec: Dict[str, Any], mode: str) -> Optional[int]:
    """Return minutes for mode from various sheet key variants, as integer minutes."""
    if mode == "walk":
        v = _pick(rec, "walk_min", "Walk_time", "Walk_time(mins)", "walk_time", "walk_time(mins)")
    elif mode == "cab":
        v = _pick(rec, "cab_min", "Cab_time")
    elif mode == "bus":
        v = _pick(rec, "bus_min", "Bus_time")
    elif mode == "tram":
        v = _pick(rec, "tram_min", "Tram_time", "tram/tube_time")
    elif mode == "train":
        v = _pick(rec, "train_min", "Train_time")
    else:
        v = None
    if v is None:
        return None
    return int(round(v))

def _get_transfer_cnt(rec: Dict[str, Any], mode: str) -> int:
    if mode == "bus":
        v = _pick(rec, "bus_cnt", "Bus_count")
    elif mode == "tram":
        v = _pick(rec, "tram_cnt", "Tram_count", "tram/tube_count")
    else:
        v = 0
    return int(round(v or 0))

# --------------------------------
# Default policy + loader
# --------------------------------
def default_policy() -> Dict[str, Any]:
    """AI-generated policy from Gemini - no fallback defaults"""
    # This function should never be called in normal operation
    # All policies should come from policy_synthesizer.py via Gemini
    raise RuntimeError(
        "Default policy removed. All policies must be generated by Gemini AI. "
        "Check that policy_synthesizer.py is properly integrated."
    )

def _merge_dict(dst: Dict[str, Any], src: Optional[Dict[str, Any]]) -> Dict[str, Any]:
    """Merge source dict into destination dict recursively"""
    if not isinstance(src, dict): 
        return dst
    for k, v in src.items():
        if isinstance(v, dict) and isinstance(dst.get(k), dict):
            _merge_dict(dst[k], v)
        else:
            dst[k] = v
    return dst

def _lex_from_order(order: List[str]) -> Dict[str, int]:
    """Generate lexicographic weights from priority order"""
    SAFE_LEX_BASE = 10**6
    MAX_WEIGHT = 10**12
    n = len(order)
    weights: Dict[str, int] = {}
    for i, k in enumerate(order):
        w = SAFE_LEX_BASE ** (n - i)
        if w > MAX_WEIGHT: 
            w = MAX_WEIGHT
        weights[k] = int(w)
    return weights

def load_policy(path: Optional[str]) -> Dict[str, Any]:
    """Load policy from file or use AI-generated policy"""
    if path and os.path.exists(path):
        try:
            with open(path, "r", encoding="utf-8") as f:
                pol = json.load(f)
                print(f"📁 Loaded policy from file: {path}")
                
                # Generate weights if not present
                if "priority_weights" not in pol and isinstance(pol.get("priority_order"), list):
                    pol["priority_weights"] = _lex_from_order(pol["priority_order"])
                
                return pol
        except Exception as e:
            print(f"⚠️  Warning: Failed to load policy from {path}: {e}")
    
    # Try to get AI-generated policy from state
    # This should be set by the orchestrator before calling the planner
    raise RuntimeError(
        "No policy provided. The orchestrator must generate a policy using "
        "policy_synthesizer.py before calling the intracity planner. "
        "Check that the policy synthesis step is working correctly."
    )

# --------------------------------
# Core solve (one hotel)
# --------------------------------
def _solve_one_hotel(data: Dict[str, Any], policy: Dict[str, Any], hname: str,
                     cp_verbose: bool = False) -> Dict[str, Any]:
    """Solve planning for one hotel with updated cost and stamina systems"""
    
    hotels = data["hotels"]
    pois = data["pois"]
    N = len(pois)
    
    # ===== POLICY CONFIGURATION =====
    stamina_config = policy.get("stamina", {})
    budget_config = policy.get("budget", {})
    planning_config = policy.get("planning", {})
    preferences_config = policy.get("preferences", {})
    comfort_config = policy.get("comfort", {})
    objective_config = policy.get("objective", {})
    solver_config = policy.get("solver", {})
    
    # ===== DETAILED DEBUGGING INFORMATION =====
    log.info(f"=== PLANNING DATA ANALYSIS FOR {hname} ===")
    log.info(f"[POLICY] Using policy: {policy.get('unique_id', 'agent_generated')}")
    log.info(f"[POLICY] Policy keys: {list(policy.keys())}")
    log.info(f"[POLICY] Budget daily cap: £{budget_config.get('daily_cap', 'N/A')}")
    log.info(f"[POLICY] Stamina start: {stamina_config.get('start', 'N/A')}")
    log.info(f"[POLICY] Max POIs per day: {planning_config.get('max_pois_per_day', 'N/A')}")
    log.info(f"Total POIs available: {N}")
    log.info(f"Total hotels available: {len(hotels)}")
    
    # Show POI details
    log.info(f"\nPOI DETAILS:")
    for i, poi in enumerate(pois):
        log.info(f"  POI {i+1}: {poi.get('name', 'N/A')} | Category: {poi.get('category', 'N/A')} | Rating: {poi.get('rating', 'N/A')}")
    
    # Show hotel details
    log.info(f"\nHOTEL DETAILS:")
    for i, hotel in enumerate(hotels):
        log.info(f"  Hotel {i+1}: {hotel.get('name', 'N/A')} | City: {hotel.get('city', 'N/A')}")
    
    # POI name→index map (1..N). Start=0, End=N+1
    idx_of = {_namekey(p["name"]): i+1 for i,p in enumerate(pois)}
    start, end = 0, N+1
    
    log.info(f"\nPOI INDEX MAPPING:")
    for name, idx in idx_of.items():
        log.info(f"  '{name}' -> index {idx}")
    
    # Select hotel (fallback to first if not exact match)
    H = next((h for h in hotels if _namekey(h.get("name")) == _namekey(hname)), hotels[0])
    log.info(f"\nSELECTED HOTEL: {H.get('name', 'N/A')}")
    
    # Init structures
    modes = ["walk", "bus", "tram", "train", "cab"]
    TT = {m: [[None]*(N+2) for _ in range(N+2)] for m in modes}
    TRANSF = {m: [[0]*(N+2) for _ in range(N+2)] for m in ("bus","tram")}
    EDGEKM = [[None]*(N+2) for _ in range(N+2)]
    
    # --- HOTEL ↔ POI from bundle
    hotel_times_all = (data.get("hotel_poi_mode_times") or {})
    log.info(f"\nHOTEL-POI MODE TIMES DATA:")
    log.info(f"  Available hotel keys: {list(hotel_times_all.keys())}")
    
    hrow = hotel_times_all.get(_namekey(hname)) or hotel_times_all.get(_namekey(H.get("name","")))
    if hrow:
        log.info(f"  Found data for hotel: {_namekey(hname)} or {_namekey(H.get('name',''))}")
        log.info(f"  Available POI keys in hotel data: {list(hrow.keys())}")
        
        for poi_name, rec in hrow.items():
            j = idx_of.get(_namekey(poi_name))
            if not j:
                log.info(f"    POI '{poi_name}' not found in POI list")
                continue
            log.info(f"    POI '{poi_name}' -> index {j}")
            
            edge_km = _pick_edge_km(rec)
            if edge_km is not None:
                EDGEKM[start][j] = edge_km
                EDGEKM[j][end]   = edge_km
                log.info(f"      Edge distance: {edge_km} km")
            else:
                log.info(f"      No edge distance found")
            
            for m in modes:
                t = _get_time_fields(rec, m)
                if t is not None and t > 0:
                    TT[m][start][j] = int(t)
                    TT[m][j][end]   = int(t)
                    log.info(f"      {m} time: {t} minutes")
                else:
                    log.info(f"      {m} time: not available")
            
            TRANSF["bus"][start][j]  = _get_transfer_cnt(rec, "bus")
            TRANSF["bus"][j][end]    = _get_transfer_cnt(rec, "bus")
            TRANSF["tram"][start][j] = _get_transfer_cnt(rec, "tram")
            TRANSF["tram"][j][end]   = _get_transfer_cnt(rec, "tram")
    else:
        log.info(f"  NO HOTEL-POI DATA FOUND!")
    
    # --- POI ↔ POI from bundle
    poi_times = (data.get("poi_mode_times") or {})
    log.info(f"\nPOI-POI MODE TIMES DATA:")
    log.info(f"  Available POI-POI keys: {list(poi_times.keys())}")
    
    def _iter_poi_pairs():
        for k, rec in poi_times.items():
            if isinstance(k, (list, tuple)) and len(k)==2:
                yield _namekey(k[0]), _namekey(k[1]), rec
            elif isinstance(k, str) and "|||" in k:
                a,b = k.split("|||",1)
                yield _namekey(a), _namekey(b), rec
            elif isinstance(k, str) and "->" in k:
                a,b = k.split("->",1)
                yield _namekey(a), _namekey(b), rec
            else:
                continue
    
    poi_poi_edges = 0
    for src, dst, rec in _iter_poi_pairs():
        i = idx_of.get(src)
        j = idx_of.get(dst)
        if not i or not j or i==j:
            log.info(f"    Edge '{src}' -> '{dst}': invalid indices (i={i}, j={j})")
            continue
        
        poi_poi_edges += 1
        log.info(f"    Edge '{src}' (index {i}) -> '{dst}' (index {j})")
        
        edge_km = _pick_edge_km(rec)
        if edge_km is not None:
            EDGEKM[i][j] = edge_km
            log.info(f"      Distance: {edge_km} km")
        else:
            log.info(f"      No distance data")
        
        for m in modes:
            t = _get_time_fields(rec, m)
            if t is not None and t > 0:
                TT[m][i][j] = int(t)
                log.info(f"      {m} time: {t} minutes")
            else:
                log.info(f"      {m} time: not available")
        
        TRANSF["bus"][i][j]  = _get_transfer_cnt(rec, "bus")
        TRANSF["tram"][i][j] = _get_transfer_cnt(rec, "tram")
    
    log.info(f"  Total POI-POI edges processed: {poi_poi_edges}")
    
    # Show final data structures
    log.info(f"\nFINAL DATA STRUCTURES:")
    log.info(f"  EDGEKM matrix size: {len(EDGEKM)}x{len(EDGEKM[0]) if EDGEKM else 0}")
    log.info(f"  TT matrices size: {len(TT)} modes x {len(TT['walk'])}x{len(TT['walk'][0]) if TT['walk'] else 0}")
    
    # Count available edges
    available_edges = 0
    for i in range(N+2):
        for j in range(N+2):
            if i != j and EDGEKM[i][j] is not None:
                available_edges += 1
    
    log.info(f"  Total available edges with distance data: {available_edges}")
    
    # Count available transport modes
    available_modes_count = 0
    for mode in modes:
        for i in range(N+2):
            for j in range(N+2):
                if i != j and TT[mode][i][j] is not None and TT[mode][i][j] > 0:
                    available_modes_count += 1
    
    log.info(f"  Total available transport mode connections: {available_modes_count}")
    
    # --- Determine available edges and modes
    max_one_way_hotel_km = float(planning_config.get("max_one_way_distance_from_hotel_km", 10**9))
    max_poi_to_poi_km = float(planning_config.get("max_poi_to_poi_distance_km", 15.0))  # New constraint for POI-to-POI
    log.info(f"\nCONSTRAINT ANALYSIS:")
    log.info(f"  Max one-way distance from hotel: {max_one_way_hotel_km} km")
    log.info(f"  Max POI-to-POI distance: {max_poi_to_poi_km} km")
    
    available_modes: Dict[Tuple[int,int], List[str]] = {}
    for i in range(N+2):
        for j in range(N+2):
            if i == j:
                continue
            # must have edge distance
            edge_km = EDGEKM[i][j]
            if edge_km is None:
                continue
            
            # Hotel↔POI edges: check hotel distance limit
            if (i == start or j == end) and edge_km > max_one_way_hotel_km:
                log.info(f"    Edge {i}->{j}: distance {edge_km}km exceeds hotel limit {max_one_way_hotel_km}km")
                continue
            
            # POI↔POI edges: check POI-to-POI distance limit
            if (i != start and i != end and j != start and j != end) and edge_km > max_poi_to_poi_km:
                log.info(f"    Edge {i}->{j}: distance {edge_km}km exceeds POI-to-POI limit {max_poi_to_poi_km}km")
                continue
            
            ms: List[str] = []
            for m in modes:
                tmin = TT[m][i][j]
                if tmin is None or tmin <= 0:
                    continue
                ms.append(m)
            
            if ms:
                available_modes[(i,j)] = ms
                if i == start or j == end:
                    log.info(f"    Hotel edge {i}->{j}: distance {edge_km}km, modes {ms}")
                else:
                    log.info(f"    POI edge {i}->{j}: distance {edge_km}km, modes {ms}")
    
    log.info(f"  Total available edges after constraints: {len(available_modes)}")
    
    if not available_modes:
        log.info(f"  RESULT: No valid edges found - planning impossible!")
        return {"status": "infeasible", "hotel": H.get("name",""), "reason": "no valid edges"}
    
    log.info(f"  RESULT: Planning possible with {len(available_modes)} edges")
    
    # --------------------------------
    # CP-SAT model
    # --------------------------------
    model = cp_model.CpModel()
    
    log.info(f"\n=== CP-SAT MODEL CONSTRUCTION ===")
    log.info(f"  [CONSTRAINT] Starting constraint model construction")
    
    # POI selection variables
    x = {i: model.NewBoolVar(f"x_{i}") for i in range(1, N+1)}
    log.info(f"  [CONSTRAINT] Created {len(x)} POI selection variables (x_1 to x_{N})")
    
    # Edge (flow) variables only for allowed edges
    y = {(i,j): model.NewBoolVar(f"y_{i}_{j}") for (i,j) in available_modes.keys()}
    log.info(f"  [CONSTRAINT] Created {len(y)} edge flow variables for valid connections")
    
    # Mode selection for each allowed edge
    x_mode = {}
    for (i,j), ms in available_modes.items():
        for m in ms:
            x_mode[(i,j,m)] = model.NewBoolVar(f"x_mode_{i}_{j}_{m}")
    log.info(f"  [CONSTRAINT] Created {len(x_mode)} mode selection variables")
    
    # Flow constraints: create a proper tour (not multiple round-trips)
    # Start has exactly one outgoing edge (to first POI)
    # End has exactly one incoming edge (from last POI)
    # Each POI has one incoming and one outgoing edge (except start/end)
    model.Add(sum(y[(start,j)] for (i,j) in y if i == start) == 1)
    model.Add(sum(y[(i,end)]   for (i,j) in y if j == end)   == 1)
    
    # Each selected POI must have exactly one incoming and one outgoing edge
    for i in range(1, N+1):
        if (start, i) in y and (i, end) in y:
            # If POI i is selected, it must have exactly one incoming and one outgoing edge
            model.Add(sum(y[(j,i)] for (j,k) in y if k == i) == x[i])
            model.Add(sum(y[(i,j)] for (k,j) in y if k == i) == x[i])
            log.info(f"    [CONSTRAINT] POI {i}: Flow conservation enforced (in=out=1 if selected)")
    
    log.info(f"  [CONSTRAINT] Added tour flow constraints: one path from start through POIs to end")
    
    # POI count constraints - simplified
    min_pois = int(planning_config.get("min_pois_per_day", 1))
    max_pois = int(planning_config.get("max_pois_per_day", 6))
    model.Add(sum(x.values()) >= min_pois)
    model.Add(sum(x.values()) <= max_pois)
    log.info(f"  [CONSTRAINT] Added POI count constraints: {min_pois} <= POIs <= {max_pois}")
    
    # SIMPLIFIED APPROACH: Basic connectivity without over-constraining
    # Each POI can be selected independently if it has valid hotel connections
    for i in range(1, N+1):
        # Check if POI i has any valid hotel connections
        has_hotel_connection = False
        
        # Check Hotel -> POI connection
        if (start, i) in y:
            has_hotel_connection = True
            log.info(f"    [CONSTRAINT] POI {i}: Has Hotel->POI connection")
        
        # Check POI -> Hotel connection  
        if (i, end) in y:
            has_hotel_connection = True
            log.info(f"    [CONSTRAINT] POI {i}: Has POI->Hotel connection")
        
        # If POI has hotel connections, it can be selected
        if has_hotel_connection:
            log.info(f"    [CONSTRAINT] POI {i}: Can be selected (has hotel connections)")
        else:
            log.warning(f"    [CONSTRAINT] POI {i}: NO hotel connections - cannot be selected")
            # Force POI to be unselected if no hotel connections
            model.Add(x[i] == 0)
    
    # Ensure we don't select more POIs than we can visit
    # With the current data structure, we can visit multiple POIs independently
    # Each POI visit is Hotel -> POI -> Hotel
    log.info(f"  [CONSTRAINT] Simplified model: Multiple POI visits allowed (Hotel->POI->Hotel each)")
    
    # SIMPLE APPROACH: Let the solver pick POIs naturally within constraints
    log.info(f"  [CONSTRAINT] Simple connectivity: POIs with hotel connections can be selected")
    
    # CRITICAL FIX: Ensure selected POIs have transport modes assigned
    for i in range(1, N+1):
        if (start, i) in y and (i, end) in y:
            # If POI i is selected, it MUST have transport modes for both Hotel->POI and POI->Hotel
            model.Add(sum(x_mode[(start,i,m)] for m in available_modes.get((start,i), [])) == x[i])
            model.Add(sum(x_mode[(i,end,m)] for m in available_modes.get((i,end), [])) == x[i])
            log.info(f"    [CONSTRAINT] POI {i}: Transport mode assignment enforced for Hotel->POI and POI->Hotel")
    
    # Tie modes to edges
    for (i,j), ms in available_modes.items():
        if len(ms) > 0:
            # Edge (i,j) can only exist if at least one mode is selected
            model.Add(y[(i,j)] <= sum(x_mode[(i,j,m)] for m in ms))
            # At most one mode can be selected per edge
            model.Add(sum(x_mode[(i,j,m)] for m in ms) <= 1)
            log.info(f"  [CONSTRAINT] Edge ({i},{j}): modes {ms}, y[{i},{j}] <= sum(x_mode), sum(x_mode) <= 1")
    log.info(f"  [CONSTRAINT] Added mode-edge linking: each edge must have exactly one transport mode")
    
    # Remove complex TSP constraints for now - just ensure basic connectivity
    log.info(f"  [CONSTRAINT] Skipped complex TSP constraints for simplicity")
    
    # Distance cap (km) - simplified
    max_total_km_day = float(planning_config.get("max_total_distance_day_km", 50.0))
    # Only count hotel-POI distances for simplicity
    hotel_poi_distances = []
    for (i,j) in y:
        if (i == start or j == end) and EDGEKM[i][j] is not None:
            hotel_poi_distances.append(int(round(EDGEKM[i][j] * 100)) * y[(i,j)])
    if hotel_poi_distances:
        model.Add(sum(hotel_poi_distances) <= int(round(max_total_km_day * 100)))
        log.info(f"  [CONSTRAINT] Added simplified distance constraint: hotel-POI <= {max_total_km_day} km")
    else:
        log.info(f"  [CONSTRAINT] WARNING: No hotel-POI distance terms available")
    
    # ---------- Budget constraints (SIMPLIFIED) ----------
    mode_fixed_cost = {k: float(v) for k, v in budget_config.get("mode_fixed_cost", {}).items()}
    daily_cap_cents = int(round(float(budget_config.get("daily_cap", 150.0)) * 100.0))
    
    log.info(f"\n=== BUDGET CONSTRAINT ANALYSIS ===")
    log.info(f"  [CONSTRAINT] Daily budget cap: £{daily_cap_cents/100.0}")
    log.info(f"  [CONSTRAINT] Mode fixed costs: {mode_fixed_cost}")
    
    # Simplified budget: only count hotel-POI transport costs
    travel_cost_cents_terms: List[cp_model.IntVar] = []
    budget_edges = 0
    
    for (i,j), ms in available_modes.items():
        # Only count hotel-POI edges for budget
        if (i == start or j == end):
            for m in ms:
                tmin = TT[m][i][j]
                if tmin is None or tmin <= 0:
                    continue
                
                # Fixed cost for transport mode
                cost = mode_fixed_cost.get(m, 0.0)
                c_fixed = int(round(cost * 100))
                v = model.NewIntVar(0, c_fixed, f"cost_{i}_{j}_{m}")
                model.Add(v == c_fixed * x_mode[(i,j,m)])
                travel_cost_cents_terms.append(v)
                budget_edges += 1
                log.info(f"    Edge {i}->{j} mode {m}: cost £{cost} (distance {EDGEKM[i][j]}km)")
    
    log.info(f"  [CONSTRAINT] Total budget edges processed: {budget_edges}")
    
    # Simplified POI costs (assume all free for now)
    poi_ticket_cents = 0
    
    daily_spend_cents = model.NewIntVar(0, 10**9, "daily_spend_cents")
    model.Add(daily_spend_cents == poi_ticket_cents + sum(travel_cost_cents_terms))
    model.Add(daily_spend_cents <= daily_cap_cents)
    
    log.info(f"  [CONSTRAINT] Added simplified budget constraint: hotel-POI transport <= £{daily_cap_cents/100.0}")
    
    # ---------- Stamina constraints (SIMPLIFIED) ----------
    S0 = float(stamina_config.get("start", 10.0))
    
    log.info(f"\n=== STAMINA CONSTRAINT ANALYSIS ===")
    log.info(f"  [CONSTRAINT] Start stamina: {S0}")
    
    # Simplified stamina: only count POI visit costs
    poi_base_cost = float(stamina_config.get("poi_visit_cost", 1.5))
    poi_liked_reduction = float(stamina_config.get("poi_liked_reduction", 1.0))
    
    log.info(f"  [CONSTRAINT] POI stamina costs: base={poi_base_cost}, liked={poi_liked_reduction}")
    
    # Determine if POI is liked based on category
    poi_stamina_costs = []
    for i in range(1, N+1):
        poi = pois[i-1]
        category = str(poi.get("category", "")).lower()
        
        # Check if POI matches user preferences
        is_liked = any(pref in category for pref in ["museum", "historic", "cultural"])
        
        if is_liked:
            cost = poi_liked_reduction
            log.info(f"    [CONSTRAINT] POI {i} '{poi.get('name')}': LIKED category '{category}' -> stamina cost {cost}")
        else:
            cost = poi_base_cost
            log.info(f"    [CONSTRAINT] POI {i} '{poi.get('name')}': NEUTRAL category '{category}' -> stamina cost {cost}")
        
        poi_stamina_costs.append(int(round(cost * 100)))
    
    # Calculate total POI stamina cost
    poi_stamina_terms = [poi_stamina_costs[i-1] * x[i] for i in range(1, N+1)]
    
    # Simplified stamina constraint: just ensure we don't go below 0
    total_poi_stamina = sum(poi_stamina_terms)
    model.Add(total_poi_stamina <= int(round(S0 * 100)))
    
    log.info(f"  [CONSTRAINT] Added simplified stamina constraint: total POI stamina <= start stamina")
    
    # ---------- TIME CONSTRAINTS (NEW) ----------
    log.info(f"\n=== TIME CONSTRAINT ANALYSIS ===")
    
    # Get time constraints from planning config
    max_daily_total_time_hours = float(planning_config.get("max_daily_total_time_hours", 8.0))
    max_daily_travel_time_hours = float(planning_config.get("max_daily_travel_time_hours", 3.0))
    poi_visit_times = planning_config.get("poi_visit_times", {
        "favorite_categories": 120,  # 2 hours for museums, historic, cultural
        "neutral_categories": 90,    # 1.5 hours for shopping, parks
        "disliked_categories": 60    # 1 hour for disliked activities
    })
    
    log.info(f"  [CONSTRAINT] Daily time limits: total={max_daily_total_time_hours}h, travel={max_daily_travel_time_hours}h")
    log.info(f"  [CONSTRAINT] POI visit times: favorite={poi_visit_times['favorite_categories']}min, neutral={poi_visit_times['neutral_categories']}min, disliked={poi_visit_times['disliked_categories']}min")
    
    # Calculate POI visit times based on preferences
    poi_visit_time_terms = []
    for i in range(1, N+1):
        poi = pois[i-1]
        category = str(poi.get("category", "")).lower()
        
        # Determine visit time based on category preference
        if any(pref in category for pref in ["museum", "historic", "cultural", "arts"]):
            visit_time = poi_visit_times["favorite_categories"]
            log.info(f"    [CONSTRAINT] POI {i} '{poi.get('name')}': FAVORITE category '{category}' -> visit time {visit_time} minutes")
        elif any(pref in category for pref in ["shopping", "park", "nightlife", "entertainment"]):
            visit_time = poi_visit_times["neutral_categories"]
            log.info(f"    [CONSTRAINT] POI {i} '{poi.get('name')}': NEUTRAL category '{category}' -> visit time {visit_time} minutes")
        else:
            visit_time = poi_visit_times["disliked_categories"]
            log.info(f"    [CONSTRAINT] POI {i} '{poi.get('name')}': DISLIKED category '{category}' -> visit time {visit_time} minutes")
        
        poi_visit_time_terms.append(visit_time * x[i])
    
    # Total POI visit time
    total_poi_visit_time = sum(poi_visit_time_terms)
    
    # Calculate travel time (from existing travel time calculation)
    travel_time_terms = []
    for (i,j), ms in available_modes.items():
        if (i == start or j == end):  # Only hotel-POI edges
            for m in ms:
                tmin = TT[m][i][j]
                if tmin is None or tmin <= 0:
                    continue
                travel_time_terms.append(tmin * x_mode[(i,j,m)])
    
    total_travel_time = sum(travel_time_terms)
    
    # Time constraints
    max_daily_total_time_minutes = int(max_daily_total_time_hours * 60)
    max_daily_travel_time_minutes = int(max_daily_travel_time_hours * 60)
    
    # Total time constraint: POI visits + travel time <= daily limit
    model.Add(total_poi_visit_time + total_travel_time <= max_daily_total_time_minutes)
    log.info(f"  [CONSTRAINT] Added total time constraint: POI visits + travel <= {max_daily_total_time_minutes} minutes")
    
    # Travel time constraint: travel time <= travel limit
    model.Add(total_travel_time <= max_daily_travel_time_minutes)
    log.info(f"  [CONSTRAINT] Added travel time constraint: travel <= {max_daily_travel_time_minutes} minutes")
    
    # ---------- POI scoring ----------
    poi_score = 0
    for i in range(1, N+1):
        rating = float(pois[i-1].get("rating", 1.0))
        poi_score += int(round(100 * rating)) * x[i]
    
    # Experience scoring based on preferences
    must_include = [s.lower() for s in (preferences_config.get("must_include") or [])]
    must_avoid   = [s.lower() for s in (preferences_config.get("must_avoid") or [])]
    include_bonus = 3  # +3 for must-include
    avoid_penalty = 2   # -2 for must-avoid
    
    log.info(f"\n=== POI SCORING ANALYSIS ===")
    log.info(f"  [CONSTRAINT] Must include categories: {must_include} (+{include_bonus} points each)")
    log.info(f"  [CONSTRAINT] Must avoid categories: {must_avoid} (-{avoid_penalty} points each)")
    
    poi_cat = [""]*(N+2)
    for i,p in enumerate(pois, start=1):
        poi_cat[i] = str(p.get("category","")).lower()
    
    # Must-include bonus
    include_terms = []
    for i in range(1, N+1):
        if any(kw in poi_cat[i] for kw in must_include):
            include_terms.append(include_bonus * x[i])
            log.info(f"    [CONSTRAINT] POI {i} '{pois[i-1].get('name')}': matches must-include -> +{include_bonus} points")
    include_term = model.NewIntVar(0, include_bonus * N, "include_term")
    model.Add(include_term == (sum(include_terms) if include_terms else 0))
    
    # Must-avoid penalty
    avoid_terms = []
    for i in range(1, N+1):
        if any(kw in poi_cat[i] for kw in must_avoid):
            avoid_terms.append(avoid_penalty * x[i])
            log.info(f"    [CONSTRAINT] POI {i} '{pois[i-1].get('name')}': matches must-avoid -> -{avoid_penalty} points")
    avoid_term = model.NewIntVar(0, avoid_penalty * N, "avoid_term")
    model.Add(avoid_term == (sum(avoid_terms) if avoid_terms else 0))
    
    # Experience score
    experience_score = model.NewIntVar(-avoid_penalty * N, include_bonus * N, "experience_score")
    model.Add(experience_score == include_term - avoid_term)
    
    # ---------- Comfort penalties ----------
    log.info(f"\n=== COMFORT CONSTRAINT ANALYSIS ===")
    discomfort_per_min = comfort_config.get("discomfort_per_min", {})
    log.info(f"  [CONSTRAINT] Transport discomfort factors: {discomfort_per_min}")
    
    transport_discomfort_terms: List[cp_model.IntVar] = []
    for (i,j), ms in available_modes.items():
        for m in ms:
            tmin = TT[m][i][j]
            if tmin is None:
                continue
            dpm = float(discomfort_per_min.get(m, 1.0))
            cost_i = int(round(dpm * tmin * 100))
            v = model.NewIntVar(0, cost_i, f"disc_{i}_{j}_{m}")
            model.Add(v == cost_i * x_mode[(i,j,m)])
            transport_discomfort_terms.append(v)
    transport_discomfort = sum(transport_discomfort_terms)
    
    # Transfer penalty
    transfer_penalty = int(round(float(comfort_config.get("transfer_penalty_per_change", 0.0)) * 100))
    log.info(f"  [CONSTRAINT] Transfer penalty per change: {transfer_penalty/100.0}")
    
    transfer_terms: List[cp_model.IntVar] = []
    if transfer_penalty > 0:
        for (i,j), ms in available_modes.items():
            for m in ("bus","tram"):
                if m not in ms:
                    continue
                cnt = int(TRANSF[m][i][j])
                if cnt <= 0: 
                    continue
                v = model.NewIntVar(0, transfer_penalty * cnt, f"trans_{i}_{j}_{m}")
                model.Add(v == transfer_penalty * cnt * x_mode[(i,j,m)])
                transfer_terms.append(v)
    transfer_cost = sum(transfer_terms)
    
    # ---------- Objective function (SIMPLIFIED) ----------
    # Simple objective: maximize POI score
    model.Maximize(poi_score)
    
    log.info(f"\n=== OBJECTIVE FUNCTION ===")
    log.info(f"  [CONSTRAINT] Objective: maximize POI score (simplified)")
    
    # ---------- Solve ----------
    solver = cp_model.CpSolver()
    solver.parameters.max_time_in_seconds = float(solver_config.get("max_seconds", 10.0))
    solver.parameters.num_search_workers = int(solver_config.get("workers", 8))
    solver.parameters.log_to_stdout = bool(cp_verbose)
    
    log.info(f"\n=== SOLVER CONFIGURATION ===")
    log.info(f"  Max time: {solver.parameters.max_time_in_seconds} seconds")
    log.info(f"  Workers: {solver.parameters.num_search_workers}")
    log.info(f"  Verbose: {cp_verbose}")
    
    t0 = time.perf_counter()
    status = solver.Solve(model)
    dt = time.perf_counter() - t0
    log.info(f"[{H.get('name','')}] Status={solver.StatusName(status)} solve_time={dt:.2f}s")
    
    if status not in (cp_model.OPTIMAL, cp_model.FEASIBLE):
        log.info(f"  SOLVER FAILED: {solver.StatusName(status)}")
        log.info(f"  This means the CP-SAT model could not find a feasible solution")
        log.info(f"  Possible reasons:")
        log.info(f"    1. No valid edges between POIs")
        log.info(f"    2. Distance constraints too restrictive")
        log.info(f"    3. Budget constraints impossible to satisfy")
        log.info(f"    4. Stamina requirements impossible to meet")
        return {"status": "infeasible", "hotel": H.get("name",""), "reason": "no feasible solution"}
    
    log.info(f"  SOLVER SUCCESS: {solver.StatusName(status)}")
    log.info(f"  Objective value: {solver.ObjectiveValue()}")
    
    # Reconstruct path - FIXED to show proper tour structure
    succ = {i: None for i in range(N+2)}
    for (i,j) in y:
        if solver.Value(y[(i,j)]) == 1:
            succ[i] = j
    
    log.info(f"  [PATH] Successor mapping: {succ}")
    log.info(f"  [PATH] Start node: {start}, End node: {end}")
    
    # NEW APPROACH: Show tour path through selected POIs
    selected_pois = []
    for i in range(1, N+1):
        if solver.Value(x[i]) == 1:
            selected_pois.append(i)
            log.info(f"  [PATH] POI {i} '{pois[i-1].get('name', 'Unknown')}' is SELECTED")
    
    log.info(f"  [PATH] Total POIs selected: {len(selected_pois)}")
    
    # Create visits for the tour (Hotel -> POI1 -> POI2 -> ... -> POIn -> Hotel)
    visits = []
    total_travel_cost = 0.0
    total_travel_time = 0
    total_distance_km = 0.0
    mode_usage = {"walk":0.0,"bus":0.0,"tram":0.0,"train":0.0,"cab":0.0}
    
    # Follow the tour path
    current_node = start
    tour_path = []
    
    # Build the tour path
    while current_node != end and len(tour_path) < len(selected_pois) + 1:
        next_node = succ.get(current_node)
        if next_node is None:
            break
        tour_path.append((current_node, next_node))
        current_node = next_node
    
    log.info(f"  [PATH] Tour path: {tour_path}")
    
    # Create visits for each segment of the tour
    for from_node, to_node in tour_path:
        if from_node == start:
            from_name = "Hotel"
        elif from_node == end:
            from_name = "Hotel"
        else:
            from_name = pois[from_node-1].get('name', f'POI {from_node}')
            
        if to_node == start:
            to_name = "Hotel"
        elif to_node == end:
            to_name = "Hotel"
        else:
            to_name = pois[to_node-1].get('name', f'POI {to_node}')
        
        # Find the transport mode for this segment
        segment_mode = None
        segment_time = 0
        segment_cost = 0.0
        
        if (from_node, to_node) in y and solver.Value(y[(from_node, to_node)]) == 1:
            # Find which transport mode was selected
            for mode in modes:
                if (from_node, to_node, mode) in x_mode and solver.Value(x_mode[(from_node, to_node, mode)]) == 1:
                    segment_mode = mode
                    segment_time = TT[mode][from_node][to_node]
                    segment_cost = mode_fixed_cost.get(mode, 0.0)
                    break
        
        if segment_mode:
            visits.append({
                "from": from_name,
                "to": to_name,
                "mode": segment_mode,
                "travel_min": segment_time,
                "cost": segment_cost
            })
            mode_usage[segment_mode] += segment_time
            total_travel_time += segment_time
            total_travel_cost += segment_cost
            if EDGEKM[from_node][to_node]:
                total_distance_km += EDGEKM[from_node][to_node]
            log.info(f"  [PATH] Added tour segment: {from_name} -> {to_name} ({segment_mode}, {segment_time}min, £{segment_cost})")
        else:
            log.warning(f"  [PATH] No transport mode found for {from_name} -> {to_name}")
    
    # Calculate final stamina
    stamina_end = S0
    for poi_idx in selected_pois:
        poi = pois[poi_idx-1]
        category = str(poi.get("category", "")).lower()
        is_liked = any(pref in category for pref in ["museum", "historic", "cultural"])
        if is_liked:
            stamina_end -= poi_liked_reduction
        else:
            stamina_end -= poi_base_cost
        log.info(f"  [STAMINA] POI {poi_idx} '{poi.get('name')}': stamina cost {poi_liked_reduction if is_liked else poi_base_cost}, remaining: {stamina_end}")
    
    # Calculate POI score
    poi_score = 0
    for poi_idx in selected_pois:
        rating = float(pois[poi_idx-1].get("rating", 1.0))
        poi_score += rating
        log.info(f"  [SCORE] POI {poi_idx} '{pois[poi_idx-1].get('name')}': rating {rating}, total score: {poi_score}")
    
    # Calculate experience score
    experience_score = 0
    for poi_idx in selected_pois:
        poi = pois[poi_idx-1]
        category = str(poi.get("category", "")).lower()
        if any(kw in category for kw in must_include):
            experience_score += include_bonus
            log.info(f"  [EXPERIENCE] POI {poi_idx} '{poi.get('name')}': +{include_bonus} for must-include category")
        if any(kw in category for kw in must_avoid):
            experience_score -= avoid_penalty
            log.info(f"  [EXPERIENCE] POI {poi_idx} '{poi.get('name')}': -{avoid_penalty} for must-avoid category")
    
    log.info(f"  [FINAL] Total visits: {len(visits)}, POIs: {len(selected_pois)}, Score: {poi_score:.1f}, Experience: {experience_score}")
    
    out = {
        "status": "ok",
        "hotel": H.get("name",""),
        "objective": solver.ObjectiveValue(),
        "budget_spend": round(solver.Value(daily_spend_cents)/100.0, 2),
        "stamina_end": stamina_end,
        "poi_score": poi_score/100.0,
        "experience_score": experience_score,
        "comfort_penalty": 0.0,  # Default value since comfort variables were simplified
        "selected_count": len(selected_pois),
        "visits": visits,
        "solve_time_s": round(dt, 2),
        "modal_split": {k: round(v,1) for k,v in mode_usage.items() if v>0},
        "total_travel_time_min": int(total_travel_time),
        "total_travel_cost_gbp": round(total_travel_cost, 2),
        "total_distance_km": round(total_distance_km, 1),
    }
    return out

# --------------------------------
# Public API: solve across hotels
# --------------------------------
def solve_intracity_city_day(data: Dict[str, Any], policy: Dict[str, Any], cp_verbose: bool=False) -> Dict[str, Any]:
    """Solve once per hotel and return the best result by user criteria: more POIs, least cost, least distance."""
    hotels = data.get("hotels", [])
    if not hotels:
        return {"status": "error", "error": "no hotels provided"}
    
    best = None
    per_hotel = []
    for H in hotels:
        name = H.get("name","")
        res = _solve_one_hotel(data, policy, name, cp_verbose=cp_verbose)
        per_hotel.append(res)
        
        # Only consider successful plans
        if res.get("status") != "ok":
            continue
            
        # Select best plan based on user criteria:
        # 1. More POIs (higher selected_count)
        # 2. Least total distance (lower total_distance_km) - PRIORITY CHANGED
        # 3. Least total travel cost (lower total_travel_cost_gbp) - SECONDARY
        
        log.info(f"  [PLAN SELECTION] Evaluating plan for {name}: {res['selected_count']} POIs, £{res['total_travel_cost_gbp']} cost, {res['total_distance_km']}km")
        
        if best is None:
            best = res
            log.info(f"  [PLAN SELECTION] First plan selected as best: {name}")
        else:
            log.info(f"  [PLAN SELECTION] Comparing with current best: {best['hotel']} ({best['selected_count']} POIs, £{best['total_travel_cost_gbp']} cost, {best['total_distance_km']}km)")
            
            # Compare POI count first (highest wins)
            if res["selected_count"] > best["selected_count"]:
                log.info(f"  [PLAN SELECTION] {name} has more POIs ({res['selected_count']} vs {best['selected_count']}) - NEW BEST!")
                best = res
            elif res["selected_count"] == best["selected_count"]:
                # Same POI count, compare distance FIRST (lowest wins) - PRIORITY CHANGED
                if res["total_distance_km"] < best["total_distance_km"]:
                    log.info(f"  [PLAN SELECTION] {name} has shorter distance ({res['total_distance_km']}km vs {best['total_distance_km']}km) - NEW BEST!")
                    best = res
                elif res["total_distance_km"] == best["total_distance_km"]:
                    # Same distance, compare cost (lowest wins)
                    if res["total_travel_cost_gbp"] < best["total_travel_cost_gbp"]:
                        log.info(f"  [PLAN SELECTION] {name} has lower cost (£{res['total_travel_cost_gbp']} vs £{best['total_travel_cost_gbp']}) - NEW BEST!")
                        best = res
                    elif res["total_travel_cost_gbp"] == best["total_travel_cost_gbp"]:
                        log.info(f"  [PLAN SELECTION] {name} has same cost - keeping current best")
                    else:
                        log.info(f"  [PLAN SELECTION] {name} has higher cost - keeping current best")
                else:
                    log.info(f"  [PLAN SELECTION] {name} has longer distance - keeping current best")
            else:
                log.info(f"  [PLAN SELECTION] {name} has fewer POIs - keeping current best")
    
    if best is None:
        return {"status": "infeasible", "per_hotel": per_hotel}
    
    log.info(f"  [PLAN SELECTION] FINAL BEST PLAN: {best['hotel']} ({best['selected_count']} POIs, £{best['total_travel_cost_gbp']} cost, {best['total_distance_km']}km)")
    return {"status":"ok", "best": best, "per_hotel": per_hotel}

# --------------------------------
# CLI
# --------------------------------
def main():
    ap = argparse.ArgumentParser(description="Intracity CP-SAT day planner (updated for fixed costs)")
    ap.add_argument("--data", type=str, required=True, help="Path to data bundle JSON")
    ap.add_argument("--policy", type=str, default=None, help="Path to policy JSON (optional)")
    ap.add_argument("--cp-verbose", action="store_true", help="Show OR-Tools search logs")
    args = ap.parse_args()
    
    with open(args.data, "r", encoding="utf-8") as f:
        data = json.load(f)
    
    policy = load_policy(args.policy) if args.policy else default_policy()
    
    # Log policy information
    log.info(f"=== POLICY LOADING ===")
    if args.policy:
        log.info(f"[POLICY] Loaded policy from file: {args.policy}")
    else:
        log.info(f"[POLICY] Using default policy (empty)")
    
    log.info(f"[POLICY] Policy content: {json.dumps(policy, indent=2)}")
    
    res = solve_intracity_city_day(data, policy, cp_verbose=args.cp_verbose)
    print(json.dumps(res, indent=2))
    
if __name__ == "__main__":
    main()
